# scanner/mock_data.py

from typing import List, Dict, Any

# Import analyzer components (required for integration mock)
try:
    from .analyzer import VulnerabilityAnalyzer
    from .database import initialize_db
except ImportError as e:
    # Fallback if imports fail, though this is needed for the test to work
    print(f"FATAL: Mock integration test cannot import analyzer/database: {e}", file=sys.stderr)
    sys.exit(1)


# --- MOCK SCANNER OUTPUT (Must contain keywords likely to be in a real CVE DB) ---
MOCK_RESULTS: List[Dict[str, Any]] = [
    {
        'ip': '10.0.0.1',
        'port': 80,
        'status': 'OPEN',
        # SIMULATED BANNER: Designed to contain two matchable keywords: 'apache' and '2.4.6'
        'banner': 'Server: Apache/2.4.6 (CentOS) PHP/5.4.16', 
        'service_type': 'http'
    },
    {
        'ip': '10.0.0.2',
        'port': 21,
        'status': 'OPEN',
        # SIMULATED BANNER: Designed to contain matchable keyword: 'vsftpd/3.0.3'
        'banner': '220 (vsFTPd 3.0.3)', 
        'service_type': 'ftp'
    },
    {
        'ip': '10.0.0.3',
        'port': 443,
        'status': 'OPEN',
        # SIMULATED BANNER: This will trigger a CRITICAL Weak Credential finding (HTTPs port)
        'banner': 'Server: LiteSpeed', 
        'service_type': 'https'
    },
    {
        'ip': '10.0.0.4',
        'port': 9999,
        'status': 'OPEN',
        # SIMULATED BANNER: A clean port with no known vulnerability
        'banner': 'Custom Service v1.0', 
        'service_type': 'unknown'
    }
]

def handle_mock_execution(mock_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Executes the VulnerabilityAnalyzer against the mock scan results.
    This forces the database lookup to occur, testing the full integration.
    """
    
    # 1. Initialize DB (ensures database is connected)
    initialize_db()
    
    # 2. Instantiate the real Analyzer
    analyzer = VulnerabilityAnalyzer()
    
    # 3. Run the mock results through the live analyzer function
    # The analyzer will call get_vulnerabilities_by_keyword() for each banner.
    final_report = analyzer.analyze_scan_results(MOCK_RESULTS)
    
    # 4. Return the results generated by the analyzer (which includes DB matches)
    return final_report